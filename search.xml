<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ys</title>
    <url>/username.github.io/2025/04/16/ys/</url>
    <content><![CDATA[冷冷清清淡淡
]]></content>
  </entry>
  <entry>
    <title>Embodied Intelligence</title>
    <url>/username.github.io/2025/04/19/Embodied-Intelligence/</url>
    <content><![CDATA[
sam2
手眼标定import cv2import numpy as npdef hand_eye_calibration(object_points, image_points, camera_matrix, dist_coeffs):    &quot;&quot;&quot;    执行手眼标定（Eye-to-Hand）        参数：        object_points: 基座坐标系中的3D点坐标（Nx3 numpy数组）        image_points: 对应的图像中的2D像素坐标（Nx2 numpy数组）        camera_matrix: 相机内参矩阵（3x3 numpy数组）        dist_coeffs: 相机畸变系数（1x5 numpy数组）            返回：        transform_matrix: 基座到相机的4x4变换矩阵        reprojection_error: 重投影误差（像素）      # 使用solvePnP求解位姿    success, rvec, tvec = cv2.solvePnP(object_points, image_points,                                       camera_matrix, dist_coeffs)        if not success:        raise ValueError(&quot;PNP求解失败，请检查输入数据&quot;)        # 将旋转向量转换为旋转矩阵    rotation_matrix, _ = cv2.Rodrigues(rvec)        # 构建4x4变换矩阵    transform_matrix = np.eye(4)    transform_matrix[:3, :3] = rotation_matrix    transform_matrix[:3, 3] = tvec.flatten()        # 计算重投影误差    projected_points, _ = cv2.projectPoints(object_points, rvec, tvec,                                            camera_matrix, dist_coeffs)    reprojection_error = np.mean(np.linalg.norm(        image_points - projected_points.squeeze(), axis=1))        return transform_matrix, reprojection_error# 示例数据（需要替换为实际数据）if __name__ == &quot;__main__&quot;:    # 相机内参（示例）    camera_matrix = np.array([        [1000, 0, 640],        [0, 1000, 360],        [0, 0, 1]    ], dtype=np.float32)        # 畸变系数（示例）    dist_coeffs = np.array([0.1, -0.01, 0.001, 0.001, 0], dtype=np.float32)        # 生成模拟数据（实际应从实际系统中获取）    num_points = 20    np.random.seed(42)        # 基座坐标系中的3D点（单位：毫米）    object_points = np.random.randn(num_points, 3) * 100 + 500        # 生成临时变换矩阵用于模拟真实变换    true_rotation = cv2.Rodrigues(np.array([0.1, 0.2, 0.3]))[0]    true_translation = np.array([100, -200, 1500])        # 生成理想图像坐标    projected_points, _ = cv2.projectPoints(object_points,                                           cv2.Rodrigues(true_rotation)[0],                                          true_translation,                                          camera_matrix,                                          None)  # 不使用畸变        # 添加噪声模拟实际数据    image_points = projected_points.squeeze() + np.random.normal(0, 1, (num_points, 2))        # 执行标定    try:        tf_mat, error = hand_eye_calibration(object_points.astype(np.float32),                                            image_points.astype(np.float32),                                            camera_matrix,                                            dist_coeffs)                print(&quot;基座到相机的变换矩阵：&quot;)        print(np.round(tf_mat, 3))        print(f&quot;\n重投影误差：&#123;error:.2f&#125; 像素&quot;)            except ValueError as e:        print(str(e))



ROS2

]]></content>
  </entry>
  <entry>
    <title>blog</title>
    <url>/username.github.io/2025/04/19/blog/</url>
    <content><![CDATA[update blog
在本地仓库的根目录下执行以下命令：git submodule initgit submodule update
这两条命令会初始化子模块的配置并下载子模块的内容。完成后，再次部署到 GitHub Pages：hexo cleanhexo generatehexo deploy

]]></content>
  </entry>
  <entry>
    <title>music</title>
    <url>/username.github.io/2025/04/19/music/</url>
    <content><![CDATA[my homepage0v0
]]></content>
  </entry>
  <entry>
    <title>ctf</title>
    <url>/username.github.io/2025/04/16/ctf/</url>
    <content><![CDATA[ctf wp
‍‌⁠⁠‬⁠⁠‍⁠‌⁠‌‬‬‬‍‍﻿‌⁠‌‍⁠‬﻿﻿ysovo

]]></content>
  </entry>
</search>
